\chapter{Cell Balancing}
\label{cha:balancing}
As discussed in the introduction, the problem of battery balancing is fundamental to maximize the net battery capacity. As measured in our previous car, which didn't have any balancing capability, after one year of usage the difference between the highest and the lowest voltages exceeded 0.1V.
For the new balancing system a goal of 10mV was set.

\begin{figure}[h]
    \centering
    \input{pictures/chimera_imbalance.tex}
    \caption{Unbalanced cells}
    \label{fig:imbalance}
\end{figure}

\section{Strategia}
The cell balancing hardware on the BMS is of the passive type: the highest-voltage cells are discharged by connecting resistors in parallel. Thus, energy is converted into heat. For this reason cell balancing is only done when the battery is charging.
A hardware limitation of this particular BMS limits the discharge of two adjacent cells.

L'hardware del BMS implementa un bilanciamento di tipo passivo: non viene trasferita energia tra le celle, ma le celle con carica maggiore vengono scaricate mettendole in parallelo con dei resistori. Per questa ragione l'operazione di bilanciamento viene eseguita durante la ricarica, in modo da non scaricare inutilmente il pacco.
Una limitazione sul circuito del BMS non permette la scarica di due celle adiacenti. Questo dettaglio nel design e' stato preso in considerazione nell'implementazione dell'algoritmo di bilanciamento.

\section {Implementazione}
Per funzionare, l'algoritmo implementato prende in input il vettore delle tensioni `voltages[]` e il valore `threshold` e restituisce un vettore di booleani `indexes[]` che indica quali celle vanno scaricate.
\begin{listing}
    \begin{minted}{c}
uint8_t balancing_compute(uint16_t voltages[], uint16_t threshold, uint16_t indexes[]);
\end{minted}
    \caption{Balancing function signature}
    \label{listing:bal_signature}
\end{listing}

The algorithm is made of the selection and the evaluation part: the former compute the imbalance between cells while the latter selects the optimal combination of cells that can be discharged simultaneously.

\subsection{Imbalance}

The imbalance computation algorithm assigns to each cell an integer value that is equals to the difference between the cell and the lowest voltage cell
Let $I[i]$ be the imbalance of cell $i$.
\[
    I[i] = voltages[i] - (min\_voltage + threshold)
\]

The implementation below cuts the imbalance to values greater than zero, as cells with negative imbalance don't need to be discharged.

\begin{algorithm}[H]
    \DontPrintSemicolon
    \NoCaptionOfAlgo
    \caption[imbalance]{\INTARRAY\ \textsf{imbalance}(\INTARRAY\ $voltages$, \INTEGER\ $n$, \INTEGER\ $threshold$)}\label{algorithm:imbalance}


    $I = \INTEGER[0 \ldots n-1]$\;
    $min\_voltage=\textsf{min}(voltages)$\;
    \For{$i=0 \to\ n$}{
    $I[i] = \textsf{max}(0, voltages[i] - (min\_voltage + threshold))$\;
    }
    \Return{I}
\end{algorithm}

\section{Exclusion}
Because of a hardware limitation on the Cellboards, neighboring cells cannot be discharged simultaneously. This limitation poses the interesting challenge of finding the combination of compatible cells that need to be discharged. The problem is similar to a canonical optimization problem that can be solved efficiently with Dynamic Programming.

%Given a vector of imbalances $I$ of size $n$ select a subset of cells that maximizes total imbalance while being not-adjacent and not having null imbalance.\\
%
%Let $Cells(i)$ be a subset of indexes that maximizes the imbalance from the first $i$ cells. Given this definition, $Cells(n)$ is the optimal solution to the problem.
%
%\subsection{Base cases}
%\[
%    Cells(0)=
%    \begin{cases}
%        \{ \emptyset \} & n=0\ or\ (n=1\ and\ I[n-1]=0) \\
%    \end{cases}
%    If $n=1\ and\ I[n-1]>0$ then $Cells(0)=\{ i-1 \}$ \\
%\]
%
%\subsection{Recursive step}
%For cell $i$ two options are available:
%\begin{itemize}
%    \item if $i$ is selected, then $Cells(i)=Cells(i-2) \cup \begin{cases}\{i-1\} & I[i-1]>0\\ \{\emptyset \}& otherwise\end{cases}$
%    \item if $i$ is skipped, then $Cells(i)=Cells(i-1)$
%\end{itemize}
%The choice to select $i$ or not is made by considering the resulting set and picking the one with higher imbalance:
%\[ Cells(i) = \begin{cases}
%        Cells(i-1)                                              & I(i-1) = 0 \\
%        \mathit{highest}(Cells(i-1),\ Cells(i-2) \cup \{i - 1\} & I(i-1) > 0 \\
%    \end{cases}\]
%
%The complete solution can be expressed with the following recursive equation:
%\[
%    Cells(i) = \begin{cases}
%        \emptyset                                                & i=0                  \\
%        \{i-1\}                                                  & i=1                  \\
%        Cells(i-1)                                               & i \ge 2,\ I(i-1) = 0 \\
%        \mathit{highest}(Cells(i-1),\ Cells(i-2) \cup \{i - 1\}) & i \ge 2,\ I(i-1) > 0 \\
%    \end{cases}
%\]
%
\subsection{Concept}

Instead of finding the output set directly, the maximum sum of all imbalances is computed first by using an helper array, and then solution is recovered from it. This approach is more efficient and easier to implement than working with sets right away, especially on a microcontroller.

\subsubsection{Computing the maximum}
Let $C[i]$ be the maximum total imbalance that can be obtained with the first $i$ cells.\\
$C[n]$ is the solution of the problem.

\paragraph{Step}

For each cell $i$, two options can be considered:
\begin{enumerate}
    \item If cell $i$ is discarded, cell $i-1$ can be selected:
          \[
              C[i]=C[i-1]
          \]

    \item If cell $i$ is selected, cell $i-1$ has to be discarded, but $i-2$ can be selected:
          \[
              C[i]=I[i-1]+C[i-2]
          \]
\end{enumerate}

To maximize the total imbalance, the highest of the two possibilities is chosen:
\[
    C[i]=\max(C[i-1],\ I[i-1] + C[i-2])
\]



\paragraph{Base cases}
The base cases consider the occasion in which the input set is empty or when only one cell is present
\begin{itemize}
    \item $C[0]=0$
    \item $C[1]=I[0]$
\end{itemize}

\[
    C[i] = \begin{cases}
        0                                      & i=0      \\
        I[0]                                   & i=1      \\
        \mathit{\max}(C[i-1], C[i-2] + I[i-1]) & i \geq 2
    \end{cases}
\]
\begin{algorithm}
    \DontPrintSemicolon
    \NoCaptionOfAlgo
    \caption[exclude]{\INTEGER\ \textsf{exclude} (\INTARRAY\ $D$, \INTEGER\ $n$)}\label{algorithm:exclude}
    $\INTARRAY\ DP = \INTEGER[0 \ldots n]$\;

    $DP[0] = 0$\;
    $DP[1] = D[0]$\;

    \For{$i=2 \to\ n + 1$}{
        $DP[i] = \max(DP[i-1],\ DP[i-2] + D[i-1])$\;
    }

    \Return{$DP[n]$}\;
\end{algorithm}

\subsubsection{Reconstructing the solution}
The above equation describes a correct albeit partial solution to the problem. The final result can be constructed by analyzing the vector $C$ in a top-down fashion.

\begin{algorithm}[H]
    \DontPrintSemicolon
    \NoCaptionOfAlgo
    \caption[solution]{\SET\ \textsf{solution} (\INTARRAY\ $D$, \INTEGER\ $i$)}\label{algorithm:solution}
    \uIf{i == 0}{
        \Return{ $\{\emptyset \}$ }\;
    }
    \uElseIf{i == 1}{
        \uIf(\tcp*[h]{we only want to add cells with positive imbalance}){$D[1] > 0$}{
            \Return{ $\{0\}$ }\;
        }
        \Else{
            \Return{ $\{\emptyset \}$ }\;
        }
    }
    \uElseIf{$D[i] == D[i-1]$}{
        \Return{$\textsf{solution}(D, i-1)$}\;
    }
    \Else{
        \Return{$\textsf{solution}(D, i-2) \cup \{i-1\}$}\;
    }
\end{algorithm}

The complete algorithm is as follows:

\begin{algorithm}
    \DontPrintSemicolon
    \NoCaptionOfAlgo
    \caption[balancing]{\SET\ \textsf{balance} (\INTARRAY\ $voltages$, \INTEGER\ $n$, \INTEGER\ $threshold$)}\label{algorithm:balancing}

    \INTARRAY\ $I = \textsf{imbalance}(voltages,\ threshold)$\;

    \If{$I={\{\emptyset \}}$}{
    \Return{$\{\emptyset \}$}\;
    }

    \textsf{exclude}(I, )

    \Return{$\textsf{solution}(I, n)$}
\end{algorithm}
